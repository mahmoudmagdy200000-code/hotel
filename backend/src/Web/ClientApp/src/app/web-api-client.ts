//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    get(): Observable<void>;
    getDebugRoutes(): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Observable<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDebugRoutes(): Observable<string> {
        let url_ = this.baseUrl + "/debug-routes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDebugRoutes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDebugRoutes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetDebugRoutes(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdmin_auditClient {
    getApiAdminAuditReservationsDeletes(from: Date | null | undefined, to: Date | null | undefined, query: string | null | undefined, eventType: string | null | undefined, hotelName: string | null | undefined, limit: number | null | undefined): Observable<ReservationDeleteAuditListItemDto[]>;
    getApiAdminAuditReservations(id: number): Observable<ReservationDeleteAuditListItemDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class Admin_auditClient implements IAdmin_auditClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiAdminAuditReservationsDeletes(from: Date | null | undefined, to: Date | null | undefined, query: string | null | undefined, eventType: string | null | undefined, hotelName: string | null | undefined, limit: number | null | undefined): Observable<ReservationDeleteAuditListItemDto[]> {
        let url_ = this.baseUrl + "/api/admin/audit/reservations/deletes?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (query !== undefined && query !== null)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (eventType !== undefined && eventType !== null)
            url_ += "EventType=" + encodeURIComponent("" + eventType) + "&";
        if (hotelName !== undefined && hotelName !== null)
            url_ += "HotelName=" + encodeURIComponent("" + hotelName) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiAdminAuditReservationsDeletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiAdminAuditReservationsDeletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationDeleteAuditListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationDeleteAuditListItemDto[]>;
        }));
    }

    protected processGetApiAdminAuditReservationsDeletes(response: HttpResponseBase): Observable<ReservationDeleteAuditListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationDeleteAuditListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiAdminAuditReservations(id: number): Observable<ReservationDeleteAuditListItemDto[]> {
        let url_ = this.baseUrl + "/api/admin/audit/reservations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiAdminAuditReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiAdminAuditReservations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationDeleteAuditListItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationDeleteAuditListItemDto[]>;
        }));
    }

    protected processGetApiAdminAuditReservations(response: HttpResponseBase): Observable<ReservationDeleteAuditListItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationDeleteAuditListItemDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAttachmentsClient {
    getApiAttachmentsReservationsPdf(id: number): Observable<void>;
    headApiAttachmentsReservationsPdf(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AttachmentsClient implements IAttachmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiAttachmentsReservationsPdf(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachments/reservations/{id}/pdf";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiAttachmentsReservationsPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiAttachmentsReservationsPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiAttachmentsReservationsPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    headApiAttachmentsReservationsPdf(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Attachments/reservations/{id}/pdf";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("head", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHeadApiAttachmentsReservationsPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHeadApiAttachmentsReservationsPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processHeadApiAttachmentsReservationsPdf(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBranchesClient {
    getApiBranches(): Observable<BranchDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class BranchesClient implements IBranchesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiBranches(): Observable<BranchDto[]> {
        let url_ = this.baseUrl + "/api/branches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiBranches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchDto[]>;
        }));
    }

    protected processGetApiBranches(response: HttpResponseBase): Observable<BranchDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BranchDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdmin_listingsClient {
    getApiAdminListings(includeInactive: boolean | undefined): Observable<BranchListingDto[]>;
    createListing(command: CreateBranchListingCommand): Observable<string>;
    patchApiAdminListings(id: string, command: UpdateBranchListingCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class Admin_listingsClient implements IAdmin_listingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiAdminListings(includeInactive: boolean | undefined): Observable<BranchListingDto[]> {
        let url_ = this.baseUrl + "/api/admin/listings?";
        if (includeInactive === null)
            throw new globalThis.Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "IncludeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiAdminListings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiAdminListings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchListingDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchListingDto[]>;
        }));
    }

    protected processGetApiAdminListings(response: HttpResponseBase): Observable<BranchListingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BranchListingDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createListing(command: CreateBranchListingCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/admin/listings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateListing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateListing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateListing(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    patchApiAdminListings(id: string, command: UpdateBranchListingCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/listings/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchApiAdminListings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchApiAdminListings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPatchApiAdminListings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDashboardClient {
    getApiDashboard(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, includeRoomTypeBreakdown: boolean | null | undefined, currency: CurrencyCode | null | undefined): Observable<DashboardDto>;
}

@Injectable({
    providedIn: 'root'
})
export class DashboardClient implements IDashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiDashboard(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, includeRoomTypeBreakdown: boolean | null | undefined, currency: CurrencyCode | null | undefined): Observable<DashboardDto> {
        let url_ = this.baseUrl + "/api/dashboard?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (mode !== undefined && mode !== null)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (includeRoomTypeBreakdown !== undefined && includeRoomTypeBreakdown !== null)
            url_ += "IncludeRoomTypeBreakdown=" + encodeURIComponent("" + includeRoomTypeBreakdown) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardDto>;
        }));
    }

    protected processGetApiDashboard(response: HttpResponseBase): Observable<DashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IExpensesClient {
    getApiExpensesAll(from: Date | null | undefined, to: Date | null | undefined, category: ExpenseCategory | null | undefined, currency: CurrencyCode | null | undefined): Observable<ExpenseDto[]>;
    createExpense(command: CreateExpenseCommand): Observable<ExpenseDto>;
    getApiExpenses(id: number): Observable<ExpenseDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ExpensesClient implements IExpensesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiExpensesAll(from: Date | null | undefined, to: Date | null | undefined, category: ExpenseCategory | null | undefined, currency: CurrencyCode | null | undefined): Observable<ExpenseDto[]> {
        let url_ = this.baseUrl + "/api/expenses?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (category !== undefined && category !== null)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiExpensesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiExpensesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto[]>;
        }));
    }

    protected processGetApiExpensesAll(response: HttpResponseBase): Observable<ExpenseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpenseDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createExpense(command: CreateExpenseCommand): Observable<ExpenseDto> {
        let url_ = this.baseUrl + "/api/expenses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto>;
        }));
    }

    protected processCreateExpense(response: HttpResponseBase): Observable<ExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ExpenseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiExpenses(id: number): Observable<ExpenseDto> {
        let url_ = this.baseUrl + "/api/expenses/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiExpenses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto>;
        }));
    }

    protected processGetApiExpenses(response: HttpResponseBase): Observable<ExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFinancialsClient {
    getApiFinancialsReservationsBreakdown(id: number): Observable<ReservationFinancialBreakdownDto>;
    getApiFinancialsRevenue(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, groupBy: string | null | undefined, currency: CurrencyCode | null | undefined): Observable<RevenueSummaryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class FinancialsClient implements IFinancialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiFinancialsReservationsBreakdown(id: number): Observable<ReservationFinancialBreakdownDto> {
        let url_ = this.baseUrl + "/api/financials/reservations/{id}/breakdown";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiFinancialsReservationsBreakdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiFinancialsReservationsBreakdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationFinancialBreakdownDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationFinancialBreakdownDto>;
        }));
    }

    protected processGetApiFinancialsReservationsBreakdown(response: HttpResponseBase): Observable<ReservationFinancialBreakdownDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationFinancialBreakdownDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiFinancialsRevenue(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, groupBy: string | null | undefined, currency: CurrencyCode | null | undefined): Observable<RevenueSummaryDto> {
        let url_ = this.baseUrl + "/api/financials/revenue?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (mode !== undefined && mode !== null)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (groupBy !== undefined && groupBy !== null)
            url_ += "groupBy=" + encodeURIComponent("" + groupBy) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "Currency=" + encodeURIComponent("" + currency) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiFinancialsRevenue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiFinancialsRevenue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevenueSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevenueSummaryDto>;
        }));
    }

    protected processGetApiFinancialsRevenue(response: HttpResponseBase): Observable<RevenueSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevenueSummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOccupancyClient {
    getApiOccupancy(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, groupBy: string | null | undefined): Observable<OccupancySummaryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class OccupancyClient implements IOccupancyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiOccupancy(from: Date | null | undefined, to: Date | null | undefined, mode: string | null | undefined, groupBy: string | null | undefined): Observable<OccupancySummaryDto> {
        let url_ = this.baseUrl + "/api/occupancy?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (mode !== undefined && mode !== null)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (groupBy !== undefined && groupBy !== null)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiOccupancy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiOccupancy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OccupancySummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OccupancySummaryDto>;
        }));
    }

    protected processGetApiOccupancy(response: HttpResponseBase): Observable<OccupancySummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OccupancySummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPdfReservationsClient {
    postApiPdfReservationsUpload(listingId: string, file: FileParameter | null | undefined): Observable<PendingReservationCreatedDto>;
    postApiPdfReservationsParse(id: number): Observable<PdfParsingResultDto>;
    getApiPdfReservationsDownload(id: number): Observable<void>;
    deleteApiPdfReservations(id: number, reason: string | null | undefined): Observable<void>;
    postApiPdfReservationsUploadBatch(listingId: string, files: any[] | null | undefined): Observable<PdfBatchUploadResultDto>;
    postApiPdfReservationsParseBatch(request: PdfBatchParseRequestDto): Observable<PdfBatchParseResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class PdfReservationsClient implements IPdfReservationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    postApiPdfReservationsUpload(listingId: string, file: FileParameter | null | undefined): Observable<PendingReservationCreatedDto> {
        let url_ = this.baseUrl + "/api/pdf-reservations/upload?";
        if (listingId === undefined || listingId === null)
            throw new globalThis.Error("The parameter 'listingId' must be defined and cannot be null.");
        else
            url_ += "listingId=" + encodeURIComponent("" + listingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiPdfReservationsUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiPdfReservationsUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingReservationCreatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingReservationCreatedDto>;
        }));
    }

    protected processPostApiPdfReservationsUpload(response: HttpResponseBase): Observable<PendingReservationCreatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingReservationCreatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiPdfReservationsParse(id: number): Observable<PdfParsingResultDto> {
        let url_ = this.baseUrl + "/api/pdf-reservations/{id}/parse";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiPdfReservationsParse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiPdfReservationsParse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfParsingResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfParsingResultDto>;
        }));
    }

    protected processPostApiPdfReservationsParse(response: HttpResponseBase): Observable<PdfParsingResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfParsingResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiPdfReservationsDownload(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/pdf-reservations/{id}/download";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiPdfReservationsDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiPdfReservationsDownload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiPdfReservationsDownload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiPdfReservations(id: number, reason: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/pdf-reservations/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiPdfReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiPdfReservations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiPdfReservations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 !== undefined ? resultData409 : null as any;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiPdfReservationsUploadBatch(listingId: string, files: any[] | null | undefined): Observable<PdfBatchUploadResultDto> {
        let url_ = this.baseUrl + "/api/pdf-reservations/upload-batch?";
        if (listingId === undefined || listingId === null)
            throw new globalThis.Error("The parameter 'listingId' must be defined and cannot be null.");
        else
            url_ += "listingId=" + encodeURIComponent("" + listingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiPdfReservationsUploadBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiPdfReservationsUploadBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfBatchUploadResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfBatchUploadResultDto>;
        }));
    }

    protected processPostApiPdfReservationsUploadBatch(response: HttpResponseBase): Observable<PdfBatchUploadResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfBatchUploadResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiPdfReservationsParseBatch(request: PdfBatchParseRequestDto): Observable<PdfBatchParseResultDto> {
        let url_ = this.baseUrl + "/api/pdf-reservations/parse-batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiPdfReservationsParseBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiPdfReservationsParseBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PdfBatchParseResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PdfBatchParseResultDto>;
        }));
    }

    protected processPostApiPdfReservationsParseBatch(response: HttpResponseBase): Observable<PdfBatchParseResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PdfBatchParseResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReceptionClient {
    getApiReceptionToday(date: Date): Observable<ReceptionTodayDto>;
    getApiReceptionPendingRequests(from: Date, to: Date, includeHint: boolean | undefined, limit: number | undefined): Observable<PendingRequestsDto>;
    getApiReceptionRoomsStatus(date: Date): Observable<ReceptionRoomsStatusDto>;
    postApiReceptionReservationsCheckIn(id: number, request: CheckInRequest): Observable<ReservationStatusChangedDto>;
    postApiReceptionReservationsCheckOut(id: number, request: CheckOutRequest): Observable<ReservationStatusChangedDto>;
    postApiReceptionReservationsCancel(id: number, request: CancelRequest): Observable<ReservationStatusChangedDto>;
    postApiReceptionReservationsNoShow(id: number, request: NoShowRequest): Observable<ReservationStatusChangedDto>;
    postApiReceptionReservationsConfirm(id: number): Observable<ReservationStatusChangedDto>;
    postApiReceptionPendingRequestsConfirmAllPlan(request: GetConfirmationPlanRequest): Observable<ReservationAllocationPlanDto>;
    postApiReceptionPendingRequestsConfirmAllApply(request: ConfirmAllocationRequest): Observable<ConfirmAllocationResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ReceptionClient implements IReceptionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiReceptionToday(date: Date): Observable<ReceptionTodayDto> {
        let url_ = this.baseUrl + "/api/reception/today?";
        if (date === undefined || date === null)
            throw new globalThis.Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReceptionToday(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReceptionToday(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceptionTodayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceptionTodayDto>;
        }));
    }

    protected processGetApiReceptionToday(response: HttpResponseBase): Observable<ReceptionTodayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReceptionTodayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiReceptionPendingRequests(from: Date, to: Date, includeHint: boolean | undefined, limit: number | undefined): Observable<PendingRequestsDto> {
        let url_ = this.baseUrl + "/api/reception/pending-requests?";
        if (from === undefined || from === null)
            throw new globalThis.Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new globalThis.Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (includeHint === null)
            throw new globalThis.Error("The parameter 'includeHint' cannot be null.");
        else if (includeHint !== undefined)
            url_ += "includeHint=" + encodeURIComponent("" + includeHint) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReceptionPendingRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReceptionPendingRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingRequestsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingRequestsDto>;
        }));
    }

    protected processGetApiReceptionPendingRequests(response: HttpResponseBase): Observable<PendingRequestsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingRequestsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiReceptionRoomsStatus(date: Date): Observable<ReceptionRoomsStatusDto> {
        let url_ = this.baseUrl + "/api/reception/rooms-status?";
        if (date === undefined || date === null)
            throw new globalThis.Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReceptionRoomsStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReceptionRoomsStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceptionRoomsStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceptionRoomsStatusDto>;
        }));
    }

    protected processGetApiReceptionRoomsStatus(response: HttpResponseBase): Observable<ReceptionRoomsStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReceptionRoomsStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionReservationsCheckIn(id: number, request: CheckInRequest): Observable<ReservationStatusChangedDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/{id}/check-in";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionReservationsCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionReservationsCheckIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationStatusChangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationStatusChangedDto>;
        }));
    }

    protected processPostApiReceptionReservationsCheckIn(response: HttpResponseBase): Observable<ReservationStatusChangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationStatusChangedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionReservationsCheckOut(id: number, request: CheckOutRequest): Observable<ReservationStatusChangedDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/{id}/check-out";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionReservationsCheckOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionReservationsCheckOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationStatusChangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationStatusChangedDto>;
        }));
    }

    protected processPostApiReceptionReservationsCheckOut(response: HttpResponseBase): Observable<ReservationStatusChangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationStatusChangedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionReservationsCancel(id: number, request: CancelRequest): Observable<ReservationStatusChangedDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionReservationsCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionReservationsCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationStatusChangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationStatusChangedDto>;
        }));
    }

    protected processPostApiReceptionReservationsCancel(response: HttpResponseBase): Observable<ReservationStatusChangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationStatusChangedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionReservationsNoShow(id: number, request: NoShowRequest): Observable<ReservationStatusChangedDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/{id}/no-show";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionReservationsNoShow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionReservationsNoShow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationStatusChangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationStatusChangedDto>;
        }));
    }

    protected processPostApiReceptionReservationsNoShow(response: HttpResponseBase): Observable<ReservationStatusChangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationStatusChangedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionReservationsConfirm(id: number): Observable<ReservationStatusChangedDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/{id}/confirm";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionReservationsConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionReservationsConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationStatusChangedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationStatusChangedDto>;
        }));
    }

    protected processPostApiReceptionReservationsConfirm(response: HttpResponseBase): Observable<ReservationStatusChangedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationStatusChangedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionPendingRequestsConfirmAllPlan(request: GetConfirmationPlanRequest): Observable<ReservationAllocationPlanDto> {
        let url_ = this.baseUrl + "/api/reception/pending-requests/confirm-all/plan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionPendingRequestsConfirmAllPlan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionPendingRequestsConfirmAllPlan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationAllocationPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationAllocationPlanDto>;
        }));
    }

    protected processPostApiReceptionPendingRequestsConfirmAllPlan(response: HttpResponseBase): Observable<ReservationAllocationPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationAllocationPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReceptionPendingRequestsConfirmAllApply(request: ConfirmAllocationRequest): Observable<ConfirmAllocationResultDto> {
        let url_ = this.baseUrl + "/api/reception/pending-requests/confirm-all/apply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReceptionPendingRequestsConfirmAllApply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReceptionPendingRequestsConfirmAllApply(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfirmAllocationResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfirmAllocationResultDto>;
        }));
    }

    protected processPostApiReceptionPendingRequestsConfirmAllApply(response: HttpResponseBase): Observable<ConfirmAllocationResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfirmAllocationResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReception_reservationsClient {
    getApiReceptionReservationsSearch(query: string, date: Date | null | undefined, limit: number | undefined): Observable<ReceptionSearchResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class Reception_reservationsClient implements IReception_reservationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiReceptionReservationsSearch(query: string, date: Date | null | undefined, limit: number | undefined): Observable<ReceptionSearchResultDto> {
        let url_ = this.baseUrl + "/api/reception/reservations/search?";
        if (query === undefined || query === null)
            throw new globalThis.Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReceptionReservationsSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReceptionReservationsSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReceptionSearchResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReceptionSearchResultDto>;
        }));
    }

    protected processGetApiReceptionReservationsSearch(response: HttpResponseBase): Observable<ReceptionSearchResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReceptionSearchResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReservationsClient {
    getApiReservationsAll(from: Date | null | undefined, to: Date | null | undefined, status: ReservationStatus | null | undefined, searchTerm: string | null | undefined, includeLines: boolean): Observable<ReservationDto[]>;
    createReservation(command: CreateReservationCommand): Observable<ReservationDto>;
    getApiReservations(id: number): Observable<ReservationDto>;
    putApiReservations(id: number, command: UpdateReservationCommand): Observable<void>;
    deleteApiReservations(id: number, reason: string | null | undefined): Observable<void>;
    postApiReservationsConfirm(id: number): Observable<void>;
    postApiReservationsCheckin(id: number): Observable<void>;
    postApiReservationsCheckout(id: number): Observable<void>;
    postApiReservationsNoshow(id: number): Observable<void>;
    postApiReservationsCancel(id: number, request: CancelReservationRequest): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ReservationsClient implements IReservationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiReservationsAll(from: Date | null | undefined, to: Date | null | undefined, status: ReservationStatus | null | undefined, searchTerm: string | null | undefined, includeLines: boolean): Observable<ReservationDto[]> {
        let url_ = this.baseUrl + "/api/reservations?";
        if (from !== undefined && from !== null)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to !== undefined && to !== null)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "SearchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (includeLines === undefined || includeLines === null)
            throw new globalThis.Error("The parameter 'includeLines' must be defined and cannot be null.");
        else
            url_ += "IncludeLines=" + encodeURIComponent("" + includeLines) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReservationsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReservationsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationDto[]>;
        }));
    }

    protected processGetApiReservationsAll(response: HttpResponseBase): Observable<ReservationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createReservation(command: CreateReservationCommand): Observable<ReservationDto> {
        let url_ = this.baseUrl + "/api/reservations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReservation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReservation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationDto>;
        }));
    }

    protected processCreateReservation(response: HttpResponseBase): Observable<ReservationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ReservationDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiReservations(id: number): Observable<ReservationDto> {
        let url_ = this.baseUrl + "/api/reservations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiReservations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReservationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReservationDto>;
        }));
    }

    protected processGetApiReservations(response: HttpResponseBase): Observable<ReservationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReservationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiReservations(id: number, command: UpdateReservationCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiReservations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiReservations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiReservations(id: number, reason: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}?";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiReservations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiReservations(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReservationsConfirm(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}/confirm";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReservationsConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReservationsConfirm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiReservationsConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReservationsCheckin(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}/checkin";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReservationsCheckin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReservationsCheckin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiReservationsCheckin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReservationsCheckout(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}/checkout";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReservationsCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReservationsCheckout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiReservationsCheckout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReservationsNoshow(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}/noshow";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReservationsNoshow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReservationsNoshow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiReservationsNoshow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiReservationsCancel(id: number, request: CancelReservationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/reservations/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiReservationsCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiReservationsCancel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiReservationsCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoomsClient {
    getApiRoomsAll(roomTypeId: number | null | undefined, isActive: boolean | null | undefined, search: string | null | undefined): Observable<RoomDto[]>;
    createRoom(command: CreateRoomCommand): Observable<number>;
    getApiRooms(id: number): Observable<RoomDto>;
    putApiRooms(id: number, command: UpdateRoomCommand): Observable<void>;
    deleteApiRooms(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RoomsClient implements IRoomsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiRoomsAll(roomTypeId: number | null | undefined, isActive: boolean | null | undefined, search: string | null | undefined): Observable<RoomDto[]> {
        let url_ = this.baseUrl + "/api/rooms?";
        if (roomTypeId !== undefined && roomTypeId !== null)
            url_ += "RoomTypeId=" + encodeURIComponent("" + roomTypeId) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiRoomsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiRoomsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto[]>;
        }));
    }

    protected processGetApiRoomsAll(response: HttpResponseBase): Observable<RoomDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoomDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRoom(command: CreateRoomCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/rooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateRoom(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiRooms(id: number): Observable<RoomDto> {
        let url_ = this.baseUrl + "/api/rooms/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiRooms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomDto>;
        }));
    }

    protected processGetApiRooms(response: HttpResponseBase): Observable<RoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiRooms(id: number, command: UpdateRoomCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/rooms/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiRooms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiRooms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiRooms(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/rooms/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiRooms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiRooms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoomtypesClient {
    getApiRoomtypesAll(isActive: boolean | null | undefined): Observable<RoomTypeDto[]>;
    createRoomType(command: CreateRoomTypeCommand): Observable<number>;
    getApiRoomtypes(id: number): Observable<RoomTypeDto>;
    putApiRoomtypes(id: number, command: UpdateRoomTypeCommand): Observable<void>;
    deleteApiRoomtypes(id: number): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RoomtypesClient implements IRoomtypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getApiRoomtypesAll(isActive: boolean | null | undefined): Observable<RoomTypeDto[]> {
        let url_ = this.baseUrl + "/api/roomtypes?";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiRoomtypesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiRoomtypesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeDto[]>;
        }));
    }

    protected processGetApiRoomtypesAll(response: HttpResponseBase): Observable<RoomTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoomTypeDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRoomType(command: CreateRoomTypeCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/roomtypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoomType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoomType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateRoomType(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiRoomtypes(id: number): Observable<RoomTypeDto> {
        let url_ = this.baseUrl + "/api/roomtypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiRoomtypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiRoomtypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoomTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoomTypeDto>;
        }));
    }

    protected processGetApiRoomtypes(response: HttpResponseBase): Observable<RoomTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoomTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiRoomtypes(id: number, command: UpdateRoomTypeCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/roomtypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiRoomtypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiRoomtypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiRoomtypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteApiRoomtypes(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/roomtypes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiRoomtypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiRoomtypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiRoomtypes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUsersClient {
    postApiUsersRegister(registration: RegisterRequest): Observable<void>;
    postApiUsersLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest): Observable<AccessTokenResponse>;
    postApiUsersRefresh(refreshRequest: RefreshRequest): Observable<AccessTokenResponse>;
    getApiUsersConfirmEmail(userId: string | null, code: string | null, changedEmail: string | null | undefined): Observable<void>;
    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest): Observable<void>;
    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest): Observable<void>;
    postApiUsersResetPassword(resetRequest: ResetPasswordRequest): Observable<void>;
    postApiUsersManage2fa(tfaRequest: TwoFactorRequest): Observable<TwoFactorResponse>;
    getApiUsersManageInfo(): Observable<InfoResponse>;
    postApiUsersManageInfo(infoRequest: InfoRequest): Observable<InfoResponse>;
    getApiUsersMe(): Observable<void>;
    getApiUsers(): Observable<UserDto[]>;
    postApiUsers(command: CreateUserCommand): Observable<void>;
    putApiUsers(userId: string, command: UpdateUserCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    postApiUsersRegister(registration: RegisterRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/users/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostApiUsersLogin(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersRefresh(refreshRequest: RefreshRequest): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/users/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostApiUsersRefresh(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsersConfirmEmail(userId: string | null, code: string | null, changedEmail: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/confirmEmail?";
        if (userId === undefined)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined)
            throw new globalThis.Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsersConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsersConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiUsersConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersResendConfirmationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersForgotPassword(resetRequest: ForgotPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersResetPassword(resetRequest: ResetPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsersResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersManage2fa(tfaRequest: TwoFactorRequest): Observable<TwoFactorResponse> {
        let url_ = this.baseUrl + "/api/users/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersManage2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersManage2fa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwoFactorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwoFactorResponse>;
        }));
    }

    protected processPostApiUsersManage2fa(response: HttpResponseBase): Observable<TwoFactorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsersManageInfo(): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/api/users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsersManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsersManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processGetApiUsersManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsersManageInfo(infoRequest: InfoRequest): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/api/users/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsersManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsersManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processPostApiUsersManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsersMe(): Observable<void> {
        let url_ = this.baseUrl + "/api/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsersMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsersMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetApiUsersMe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getApiUsers(): Observable<UserDto[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto[]>;
        }));
    }

    protected processGetApiUsers(response: HttpResponseBase): Observable<UserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postApiUsers(command: CreateUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostApiUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostApiUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostApiUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putApiUsers(userId: string, command: UpdateUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutApiUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutApiUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutApiUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastsClient {
    getWeatherForecasts(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastsClient implements IWeatherForecastsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getWeatherForecasts(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeatherForecasts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeatherForecasts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGetWeatherForecasts(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ReservationDeleteAuditListItemDto implements IReservationDeleteAuditListItemDto {
    id?: number;
    reservationId?: number;
    eventType?: string;
    actorEmail?: string;
    occurredAtUtc?: Date;
    reason?: string | undefined;
    hotelName?: string | undefined;
    snapshotJson?: string | undefined;

    constructor(data?: IReservationDeleteAuditListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reservationId = _data["reservationId"];
            this.eventType = _data["eventType"];
            this.actorEmail = _data["actorEmail"];
            this.occurredAtUtc = _data["occurredAtUtc"] ? new Date(_data["occurredAtUtc"].toString()) : undefined as any;
            this.reason = _data["reason"];
            this.hotelName = _data["hotelName"];
            this.snapshotJson = _data["snapshotJson"];
        }
    }

    static fromJS(data: any): ReservationDeleteAuditListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationDeleteAuditListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reservationId"] = this.reservationId;
        data["eventType"] = this.eventType;
        data["actorEmail"] = this.actorEmail;
        data["occurredAtUtc"] = this.occurredAtUtc ? this.occurredAtUtc.toISOString() : undefined as any;
        data["reason"] = this.reason;
        data["hotelName"] = this.hotelName;
        data["snapshotJson"] = this.snapshotJson;
        return data;
    }
}

export interface IReservationDeleteAuditListItemDto {
    id?: number;
    reservationId?: number;
    eventType?: string;
    actorEmail?: string;
    occurredAtUtc?: Date;
    reason?: string | undefined;
    hotelName?: string | undefined;
    snapshotJson?: string | undefined;
}

export class BranchDto implements IBranchDto {
    id?: string;
    name?: string;

    constructor(data?: IBranchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BranchDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IBranchDto {
    id?: string;
    name?: string;
}

export class BranchListingDto implements IBranchListingDto {
    id?: string;
    name?: string;
    channel?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBranchListingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.channel = _data["channel"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): BranchListingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["channel"] = this.channel;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IBranchListingDto {
    id?: string;
    name?: string;
    channel?: string | undefined;
    isActive?: boolean;
}

export class CreateBranchListingCommand implements ICreateBranchListingCommand {
    name?: string;
    channel?: string | undefined;

    constructor(data?: ICreateBranchListingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CreateBranchListingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBranchListingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["channel"] = this.channel;
        return data;
    }
}

export interface ICreateBranchListingCommand {
    name?: string;
    channel?: string | undefined;
}

export class UpdateBranchListingCommand implements IUpdateBranchListingCommand {
    id?: string;
    name?: string | undefined;
    channel?: string | undefined;
    isActive?: boolean | undefined;

    constructor(data?: IUpdateBranchListingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.channel = _data["channel"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateBranchListingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBranchListingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["channel"] = this.channel;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateBranchListingCommand {
    id?: string;
    name?: string | undefined;
    channel?: string | undefined;
    isActive?: boolean | undefined;
}

export class DashboardDto implements IDashboardDto {
    summary?: DashboardKpiSummaryDto;
    byDay?: DashboardSeriesPointDto[];
    byRoomType?: DashboardRoomTypeKpiDto[] | undefined;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.summary = _data["summary"] ? DashboardKpiSummaryDto.fromJS(_data["summary"]) : undefined as any;
            if (Array.isArray(_data["byDay"])) {
                this.byDay = [] as any;
                for (let item of _data["byDay"])
                    this.byDay!.push(DashboardSeriesPointDto.fromJS(item));
            }
            if (Array.isArray(_data["byRoomType"])) {
                this.byRoomType = [] as any;
                for (let item of _data["byRoomType"])
                    this.byRoomType!.push(DashboardRoomTypeKpiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summary"] = this.summary ? this.summary.toJSON() : undefined as any;
        if (Array.isArray(this.byDay)) {
            data["byDay"] = [];
            for (let item of this.byDay)
                data["byDay"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.byRoomType)) {
            data["byRoomType"] = [];
            for (let item of this.byRoomType)
                data["byRoomType"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IDashboardDto {
    summary?: DashboardKpiSummaryDto;
    byDay?: DashboardSeriesPointDto[];
    byRoomType?: DashboardRoomTypeKpiDto[] | undefined;
}

export class DashboardKpiSummaryDto implements IDashboardKpiSummaryDto {
    from?: Date;
    to?: Date;
    nightsCount?: number;
    mode?: string;
    totalRooms?: number;
    supplyRoomNights?: number;
    soldRoomNights?: number;
    occupancyRateOverall?: number;
    totalRevenue?: number;
    adr?: number;
    revPar?: number;

    constructor(data?: IDashboardKpiSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            this.nightsCount = _data["nightsCount"];
            this.mode = _data["mode"];
            this.totalRooms = _data["totalRooms"];
            this.supplyRoomNights = _data["supplyRoomNights"];
            this.soldRoomNights = _data["soldRoomNights"];
            this.occupancyRateOverall = _data["occupancyRateOverall"];
            this.totalRevenue = _data["totalRevenue"];
            this.adr = _data["adr"];
            this.revPar = _data["revPar"];
        }
    }

    static fromJS(data: any): DashboardKpiSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardKpiSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        data["nightsCount"] = this.nightsCount;
        data["mode"] = this.mode;
        data["totalRooms"] = this.totalRooms;
        data["supplyRoomNights"] = this.supplyRoomNights;
        data["soldRoomNights"] = this.soldRoomNights;
        data["occupancyRateOverall"] = this.occupancyRateOverall;
        data["totalRevenue"] = this.totalRevenue;
        data["adr"] = this.adr;
        data["revPar"] = this.revPar;
        return data;
    }
}

export interface IDashboardKpiSummaryDto {
    from?: Date;
    to?: Date;
    nightsCount?: number;
    mode?: string;
    totalRooms?: number;
    supplyRoomNights?: number;
    soldRoomNights?: number;
    occupancyRateOverall?: number;
    totalRevenue?: number;
    adr?: number;
    revPar?: number;
}

export class DashboardSeriesPointDto implements IDashboardSeriesPointDto {
    date?: string;
    totalRooms?: number;
    occupiedRooms?: number;
    occupancyRate?: number;
    revenue?: number;
    adr?: number;
    revPar?: number;

    constructor(data?: IDashboardSeriesPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.totalRooms = _data["totalRooms"];
            this.occupiedRooms = _data["occupiedRooms"];
            this.occupancyRate = _data["occupancyRate"];
            this.revenue = _data["revenue"];
            this.adr = _data["adr"];
            this.revPar = _data["revPar"];
        }
    }

    static fromJS(data: any): DashboardSeriesPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardSeriesPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["totalRooms"] = this.totalRooms;
        data["occupiedRooms"] = this.occupiedRooms;
        data["occupancyRate"] = this.occupancyRate;
        data["revenue"] = this.revenue;
        data["adr"] = this.adr;
        data["revPar"] = this.revPar;
        return data;
    }
}

export interface IDashboardSeriesPointDto {
    date?: string;
    totalRooms?: number;
    occupiedRooms?: number;
    occupancyRate?: number;
    revenue?: number;
    adr?: number;
    revPar?: number;
}

export class DashboardRoomTypeKpiDto implements IDashboardRoomTypeKpiDto {
    roomTypeId?: number;
    roomTypeName?: string | undefined;
    soldRoomNights?: number;
    revenue?: number;
    adr?: number;
    occupancyRate?: number | undefined;

    constructor(data?: IDashboardRoomTypeKpiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomTypeId = _data["roomTypeId"];
            this.roomTypeName = _data["roomTypeName"];
            this.soldRoomNights = _data["soldRoomNights"];
            this.revenue = _data["revenue"];
            this.adr = _data["adr"];
            this.occupancyRate = _data["occupancyRate"];
        }
    }

    static fromJS(data: any): DashboardRoomTypeKpiDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardRoomTypeKpiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomTypeId"] = this.roomTypeId;
        data["roomTypeName"] = this.roomTypeName;
        data["soldRoomNights"] = this.soldRoomNights;
        data["revenue"] = this.revenue;
        data["adr"] = this.adr;
        data["occupancyRate"] = this.occupancyRate;
        return data;
    }
}

export interface IDashboardRoomTypeKpiDto {
    roomTypeId?: number;
    roomTypeName?: string | undefined;
    soldRoomNights?: number;
    revenue?: number;
    adr?: number;
    occupancyRate?: number | undefined;
}

export enum CurrencyCode {
    EGP = 1,
    USD = 2,
    EUR = 3,
    Other = 4,
}

export class ExpenseDto implements IExpenseDto {
    id?: number;
    businessDate?: Date;
    category?: ExpenseCategory;
    amount?: number;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
    paymentMethod?: PaymentMethod;
    description?: string;
    vendor?: string | undefined;
    created?: Date;

    constructor(data?: IExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
            this.category = _data["category"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.currencyOther = _data["currencyOther"];
            this.paymentMethod = _data["paymentMethod"];
            this.description = _data["description"];
            this.vendor = _data["vendor"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        data["category"] = this.category;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["currencyOther"] = this.currencyOther;
        data["paymentMethod"] = this.paymentMethod;
        data["description"] = this.description;
        data["vendor"] = this.vendor;
        data["created"] = this.created ? this.created.toISOString() : undefined as any;
        return data;
    }
}

export interface IExpenseDto {
    id?: number;
    businessDate?: Date;
    category?: ExpenseCategory;
    amount?: number;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
    paymentMethod?: PaymentMethod;
    description?: string;
    vendor?: string | undefined;
    created?: Date;
}

export enum ExpenseCategory {
    Maintenance = 1,
    Purchases = 2,
    Breakfast = 3,
    Other = 4,
}

export enum PaymentMethod {
    Cash = 1,
    Visa = 2,
    Other = 3,
}

export class CreateExpenseCommand implements ICreateExpenseCommand {
    businessDate?: Date;
    category?: ExpenseCategory;
    amount?: number;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
    paymentMethod?: PaymentMethod;
    description?: string;
    vendor?: string | undefined;

    constructor(data?: ICreateExpenseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
            this.category = _data["category"];
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.currencyOther = _data["currencyOther"];
            this.paymentMethod = _data["paymentMethod"];
            this.description = _data["description"];
            this.vendor = _data["vendor"];
        }
    }

    static fromJS(data: any): CreateExpenseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExpenseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        data["category"] = this.category;
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["currencyOther"] = this.currencyOther;
        data["paymentMethod"] = this.paymentMethod;
        data["description"] = this.description;
        data["vendor"] = this.vendor;
        return data;
    }
}

export interface ICreateExpenseCommand {
    businessDate?: Date;
    category?: ExpenseCategory;
    amount?: number;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
    paymentMethod?: PaymentMethod;
    description?: string;
    vendor?: string | undefined;
}

export class ReservationFinancialBreakdownDto implements IReservationFinancialBreakdownDto {
    reservationId?: number;
    checkInDate?: Date;
    checkOutDate?: Date;
    nights?: number;
    status?: ReservationStatus;
    totalAmount?: number;
    currency?: string;
    isExcludedFromRevenue?: boolean;
    lines?: ReservationLineBreakdownDto[];
    nightly?: NightlyRevenueDto[];

    constructor(data?: IReservationFinancialBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.nights = _data["nights"];
            this.status = _data["status"];
            this.totalAmount = _data["totalAmount"];
            this.currency = _data["currency"];
            this.isExcludedFromRevenue = _data["isExcludedFromRevenue"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(ReservationLineBreakdownDto.fromJS(item));
            }
            if (Array.isArray(_data["nightly"])) {
                this.nightly = [] as any;
                for (let item of _data["nightly"])
                    this.nightly!.push(NightlyRevenueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReservationFinancialBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationFinancialBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["checkInDate"] = this.checkInDate ? this.checkInDate.toISOString() : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? this.checkOutDate.toISOString() : undefined as any;
        data["nights"] = this.nights;
        data["status"] = this.status;
        data["totalAmount"] = this.totalAmount;
        data["currency"] = this.currency;
        data["isExcludedFromRevenue"] = this.isExcludedFromRevenue;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.nightly)) {
            data["nightly"] = [];
            for (let item of this.nightly)
                data["nightly"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReservationFinancialBreakdownDto {
    reservationId?: number;
    checkInDate?: Date;
    checkOutDate?: Date;
    nights?: number;
    status?: ReservationStatus;
    totalAmount?: number;
    currency?: string;
    isExcludedFromRevenue?: boolean;
    lines?: ReservationLineBreakdownDto[];
    nightly?: NightlyRevenueDto[];
}

export enum ReservationStatus {
    Draft = 1,
    Confirmed = 2,
    CheckedIn = 3,
    CheckedOut = 4,
    Cancelled = 5,
    NoShow = 6,
}

export class ReservationLineBreakdownDto implements IReservationLineBreakdownDto {
    reservationLineId?: number;
    roomId?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    ratePerNight?: number;
    lineTotal?: number;

    constructor(data?: IReservationLineBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationLineId = _data["reservationLineId"];
            this.roomId = _data["roomId"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeId = _data["roomTypeId"];
            this.roomTypeName = _data["roomTypeName"];
            this.ratePerNight = _data["ratePerNight"];
            this.lineTotal = _data["lineTotal"];
        }
    }

    static fromJS(data: any): ReservationLineBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationLineBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationLineId"] = this.reservationLineId;
        data["roomId"] = this.roomId;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeId"] = this.roomTypeId;
        data["roomTypeName"] = this.roomTypeName;
        data["ratePerNight"] = this.ratePerNight;
        data["lineTotal"] = this.lineTotal;
        return data;
    }
}

export interface IReservationLineBreakdownDto {
    reservationLineId?: number;
    roomId?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    ratePerNight?: number;
    lineTotal?: number;
}

export class NightlyRevenueDto implements INightlyRevenueDto {
    date?: string;
    amount?: number;

    constructor(data?: INightlyRevenueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): NightlyRevenueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NightlyRevenueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["amount"] = this.amount;
        return data;
    }
}

export interface INightlyRevenueDto {
    date?: string;
    amount?: number;
}

export class RevenueSummaryDto implements IRevenueSummaryDto {
    totalRevenue?: number;
    items?: RevenueSummaryItemDto[];

    constructor(data?: IRevenueSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalRevenue = _data["totalRevenue"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RevenueSummaryItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RevenueSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRevenue"] = this.totalRevenue;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRevenueSummaryDto {
    totalRevenue?: number;
    items?: RevenueSummaryItemDto[];
}

export class RevenueSummaryItemDto implements IRevenueSummaryItemDto {
    key?: string;
    revenue?: number;

    constructor(data?: IRevenueSummaryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.revenue = _data["revenue"];
        }
    }

    static fromJS(data: any): RevenueSummaryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueSummaryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["revenue"] = this.revenue;
        return data;
    }
}

export interface IRevenueSummaryItemDto {
    key?: string;
    revenue?: number;
}

export class OccupancySummaryDto implements IOccupancySummaryDto {
    from?: Date;
    to?: Date;
    nightsCount?: number;
    mode?: string;
    totalRooms?: number;
    supplyRoomNights?: number;
    soldRoomNights?: number;
    occupancyRateOverall?: number;
    byDay?: OccupancyDayDto[];
    byRoomTypeByDay?: OccupancyByRoomTypeDayDto[];

    constructor(data?: IOccupancySummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            this.nightsCount = _data["nightsCount"];
            this.mode = _data["mode"];
            this.totalRooms = _data["totalRooms"];
            this.supplyRoomNights = _data["supplyRoomNights"];
            this.soldRoomNights = _data["soldRoomNights"];
            this.occupancyRateOverall = _data["occupancyRateOverall"];
            if (Array.isArray(_data["byDay"])) {
                this.byDay = [] as any;
                for (let item of _data["byDay"])
                    this.byDay!.push(OccupancyDayDto.fromJS(item));
            }
            if (Array.isArray(_data["byRoomTypeByDay"])) {
                this.byRoomTypeByDay = [] as any;
                for (let item of _data["byRoomTypeByDay"])
                    this.byRoomTypeByDay!.push(OccupancyByRoomTypeDayDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OccupancySummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OccupancySummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? this.from.toISOString() : undefined as any;
        data["to"] = this.to ? this.to.toISOString() : undefined as any;
        data["nightsCount"] = this.nightsCount;
        data["mode"] = this.mode;
        data["totalRooms"] = this.totalRooms;
        data["supplyRoomNights"] = this.supplyRoomNights;
        data["soldRoomNights"] = this.soldRoomNights;
        data["occupancyRateOverall"] = this.occupancyRateOverall;
        if (Array.isArray(this.byDay)) {
            data["byDay"] = [];
            for (let item of this.byDay)
                data["byDay"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.byRoomTypeByDay)) {
            data["byRoomTypeByDay"] = [];
            for (let item of this.byRoomTypeByDay)
                data["byRoomTypeByDay"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOccupancySummaryDto {
    from?: Date;
    to?: Date;
    nightsCount?: number;
    mode?: string;
    totalRooms?: number;
    supplyRoomNights?: number;
    soldRoomNights?: number;
    occupancyRateOverall?: number;
    byDay?: OccupancyDayDto[];
    byRoomTypeByDay?: OccupancyByRoomTypeDayDto[];
}

export class OccupancyDayDto implements IOccupancyDayDto {
    date?: string;
    totalRooms?: number;
    occupiedRooms?: number;
    occupancyRate?: number;
    roomNightsSold?: number;
    availableRooms?: number;
    overbooked?: boolean;

    constructor(data?: IOccupancyDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.totalRooms = _data["totalRooms"];
            this.occupiedRooms = _data["occupiedRooms"];
            this.occupancyRate = _data["occupancyRate"];
            this.roomNightsSold = _data["roomNightsSold"];
            this.availableRooms = _data["availableRooms"];
            this.overbooked = _data["overbooked"];
        }
    }

    static fromJS(data: any): OccupancyDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new OccupancyDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["totalRooms"] = this.totalRooms;
        data["occupiedRooms"] = this.occupiedRooms;
        data["occupancyRate"] = this.occupancyRate;
        data["roomNightsSold"] = this.roomNightsSold;
        data["availableRooms"] = this.availableRooms;
        data["overbooked"] = this.overbooked;
        return data;
    }
}

export interface IOccupancyDayDto {
    date?: string;
    totalRooms?: number;
    occupiedRooms?: number;
    occupancyRate?: number;
    roomNightsSold?: number;
    availableRooms?: number;
    overbooked?: boolean;
}

export class OccupancyByRoomTypeDayDto implements IOccupancyByRoomTypeDayDto {
    date?: string;
    roomTypeId?: number;
    roomTypeName?: string | undefined;
    occupiedRoomsOfType?: number;
    roomNightsSoldOfType?: number;

    constructor(data?: IOccupancyByRoomTypeDayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.roomTypeId = _data["roomTypeId"];
            this.roomTypeName = _data["roomTypeName"];
            this.occupiedRoomsOfType = _data["occupiedRoomsOfType"];
            this.roomNightsSoldOfType = _data["roomNightsSoldOfType"];
        }
    }

    static fromJS(data: any): OccupancyByRoomTypeDayDto {
        data = typeof data === 'object' ? data : {};
        let result = new OccupancyByRoomTypeDayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["roomTypeId"] = this.roomTypeId;
        data["roomTypeName"] = this.roomTypeName;
        data["occupiedRoomsOfType"] = this.occupiedRoomsOfType;
        data["roomNightsSoldOfType"] = this.roomNightsSoldOfType;
        return data;
    }
}

export interface IOccupancyByRoomTypeDayDto {
    date?: string;
    roomTypeId?: number;
    roomTypeName?: string | undefined;
    occupiedRoomsOfType?: number;
    roomNightsSoldOfType?: number;
}

export class PendingReservationCreatedDto implements IPendingReservationCreatedDto {
    reservationId?: number;
    bookingNumber?: string;
    status?: string;
    createdAtUtc?: Date;
    parsingStatus?: string;
    message?: string;

    constructor(data?: IPendingReservationCreatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.bookingNumber = _data["bookingNumber"];
            this.status = _data["status"];
            this.createdAtUtc = _data["createdAtUtc"] ? new Date(_data["createdAtUtc"].toString()) : undefined as any;
            this.parsingStatus = _data["parsingStatus"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PendingReservationCreatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingReservationCreatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["bookingNumber"] = this.bookingNumber;
        data["status"] = this.status;
        data["createdAtUtc"] = this.createdAtUtc ? this.createdAtUtc.toISOString() : undefined as any;
        data["parsingStatus"] = this.parsingStatus;
        data["message"] = this.message;
        return data;
    }
}

export interface IPendingReservationCreatedDto {
    reservationId?: number;
    bookingNumber?: string;
    status?: string;
    createdAtUtc?: Date;
    parsingStatus?: string;
    message?: string;
}

export class PdfParsingResultDto implements IPdfParsingResultDto {
    reservationId?: number;
    parsingStatus?: string;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    failureStep?: string | undefined;
    correlationId?: string | undefined;
    extracted?: ExtractedPdfDataDto | undefined;
    errors?: string[];

    constructor(data?: IPdfParsingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.parsingStatus = _data["parsingStatus"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.failureStep = _data["failureStep"];
            this.correlationId = _data["correlationId"];
            this.extracted = _data["extracted"] ? ExtractedPdfDataDto.fromJS(_data["extracted"]) : undefined as any;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): PdfParsingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfParsingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["parsingStatus"] = this.parsingStatus;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["failureStep"] = this.failureStep;
        data["correlationId"] = this.correlationId;
        data["extracted"] = this.extracted ? this.extracted.toJSON() : undefined as any;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IPdfParsingResultDto {
    reservationId?: number;
    parsingStatus?: string;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    failureStep?: string | undefined;
    correlationId?: string | undefined;
    extracted?: ExtractedPdfDataDto | undefined;
    errors?: string[];
}

export class ExtractedPdfDataDto implements IExtractedPdfDataDto {
    guestName?: string | undefined;
    phone?: string | undefined;
    checkIn?: string | undefined;
    checkOut?: string | undefined;
    roomsCount?: number | undefined;
    roomTypeHint?: string | undefined;
    totalPrice?: number | undefined;
    currency?: string | undefined;
    bookingNumber?: string | undefined;

    constructor(data?: IExtractedPdfDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.roomsCount = _data["roomsCount"];
            this.roomTypeHint = _data["roomTypeHint"];
            this.totalPrice = _data["totalPrice"];
            this.currency = _data["currency"];
            this.bookingNumber = _data["bookingNumber"];
        }
    }

    static fromJS(data: any): ExtractedPdfDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtractedPdfDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["roomsCount"] = this.roomsCount;
        data["roomTypeHint"] = this.roomTypeHint;
        data["totalPrice"] = this.totalPrice;
        data["currency"] = this.currency;
        data["bookingNumber"] = this.bookingNumber;
        return data;
    }
}

export interface IExtractedPdfDataDto {
    guestName?: string | undefined;
    phone?: string | undefined;
    checkIn?: string | undefined;
    checkOut?: string | undefined;
    roomsCount?: number | undefined;
    roomTypeHint?: string | undefined;
    totalPrice?: number | undefined;
    currency?: string | undefined;
    bookingNumber?: string | undefined;
}

export class PdfBatchUploadResultDto implements IPdfBatchUploadResultDto {
    totalCount?: number;
    successCount?: number;
    failedCount?: number;
    items?: PdfBatchUploadItemResultDto[];

    constructor(data?: IPdfBatchUploadResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.successCount = _data["successCount"];
            this.failedCount = _data["failedCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PdfBatchUploadItemResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PdfBatchUploadResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfBatchUploadResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["successCount"] = this.successCount;
        data["failedCount"] = this.failedCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPdfBatchUploadResultDto {
    totalCount?: number;
    successCount?: number;
    failedCount?: number;
    items?: PdfBatchUploadItemResultDto[];
}

export class PdfBatchUploadItemResultDto implements IPdfBatchUploadItemResultDto {
    index?: number;
    fileName?: string;
    status?: string;
    reservationId?: number | undefined;
    parsingStatus?: string | undefined;
    message?: string | undefined;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPdfBatchUploadItemResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.fileName = _data["fileName"];
            this.status = _data["status"];
            this.reservationId = _data["reservationId"];
            this.parsingStatus = _data["parsingStatus"];
            this.message = _data["message"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PdfBatchUploadItemResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfBatchUploadItemResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["fileName"] = this.fileName;
        data["status"] = this.status;
        data["reservationId"] = this.reservationId;
        data["parsingStatus"] = this.parsingStatus;
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPdfBatchUploadItemResultDto {
    index?: number;
    fileName?: string;
    status?: string;
    reservationId?: number | undefined;
    parsingStatus?: string | undefined;
    message?: string | undefined;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
}

export class PdfBatchParseResultDto implements IPdfBatchParseResultDto {
    totalCount?: number;
    successCount?: number;
    failedCount?: number;
    items?: PdfBatchParseItemResultDto[];

    constructor(data?: IPdfBatchParseResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.successCount = _data["successCount"];
            this.failedCount = _data["failedCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PdfBatchParseItemResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PdfBatchParseResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfBatchParseResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["successCount"] = this.successCount;
        data["failedCount"] = this.failedCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPdfBatchParseResultDto {
    totalCount?: number;
    successCount?: number;
    failedCount?: number;
    items?: PdfBatchParseItemResultDto[];
}

export class PdfBatchParseItemResultDto implements IPdfBatchParseItemResultDto {
    index?: number;
    reservationId?: number;
    status?: string;
    parsingStatus?: string | undefined;
    message?: string | undefined;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    extracted?: ExtractedPdfDataDto | undefined;

    constructor(data?: IPdfBatchParseItemResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.reservationId = _data["reservationId"];
            this.status = _data["status"];
            this.parsingStatus = _data["parsingStatus"];
            this.message = _data["message"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.extracted = _data["extracted"] ? ExtractedPdfDataDto.fromJS(_data["extracted"]) : undefined as any;
        }
    }

    static fromJS(data: any): PdfBatchParseItemResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfBatchParseItemResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["reservationId"] = this.reservationId;
        data["status"] = this.status;
        data["parsingStatus"] = this.parsingStatus;
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["extracted"] = this.extracted ? this.extracted.toJSON() : undefined as any;
        return data;
    }
}

export interface IPdfBatchParseItemResultDto {
    index?: number;
    reservationId?: number;
    status?: string;
    parsingStatus?: string | undefined;
    message?: string | undefined;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    extracted?: ExtractedPdfDataDto | undefined;
}

export class PdfBatchParseRequestDto implements IPdfBatchParseRequestDto {
    reservationIds?: number[];

    constructor(data?: IPdfBatchParseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reservationIds"])) {
                this.reservationIds = [] as any;
                for (let item of _data["reservationIds"])
                    this.reservationIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PdfBatchParseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfBatchParseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reservationIds)) {
            data["reservationIds"] = [];
            for (let item of this.reservationIds)
                data["reservationIds"].push(item);
        }
        return data;
    }
}

export interface IPdfBatchParseRequestDto {
    reservationIds?: number[];
}

export class ReceptionTodayDto implements IReceptionTodayDto {
    date?: string;
    summary?: ReceptionTodaySummaryDto;
    arrivals?: ReceptionReservationItemDto[];
    departures?: ReceptionReservationItemDto[];
    inHouse?: ReceptionReservationItemDto[];

    constructor(data?: IReceptionTodayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.summary = _data["summary"] ? ReceptionTodaySummaryDto.fromJS(_data["summary"]) : undefined as any;
            if (Array.isArray(_data["arrivals"])) {
                this.arrivals = [] as any;
                for (let item of _data["arrivals"])
                    this.arrivals!.push(ReceptionReservationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["departures"])) {
                this.departures = [] as any;
                for (let item of _data["departures"])
                    this.departures!.push(ReceptionReservationItemDto.fromJS(item));
            }
            if (Array.isArray(_data["inHouse"])) {
                this.inHouse = [] as any;
                for (let item of _data["inHouse"])
                    this.inHouse!.push(ReceptionReservationItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReceptionTodayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionTodayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["summary"] = this.summary ? this.summary.toJSON() : undefined as any;
        if (Array.isArray(this.arrivals)) {
            data["arrivals"] = [];
            for (let item of this.arrivals)
                data["arrivals"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.departures)) {
            data["departures"] = [];
            for (let item of this.departures)
                data["departures"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.inHouse)) {
            data["inHouse"] = [];
            for (let item of this.inHouse)
                data["inHouse"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReceptionTodayDto {
    date?: string;
    summary?: ReceptionTodaySummaryDto;
    arrivals?: ReceptionReservationItemDto[];
    departures?: ReceptionReservationItemDto[];
    inHouse?: ReceptionReservationItemDto[];
}

export class ReceptionTodaySummaryDto implements IReceptionTodaySummaryDto {
    arrivalsCount?: number;
    departuresCount?: number;
    inHouseCount?: number;

    constructor(data?: IReceptionTodaySummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.arrivalsCount = _data["arrivalsCount"];
            this.departuresCount = _data["departuresCount"];
            this.inHouseCount = _data["inHouseCount"];
        }
    }

    static fromJS(data: any): ReceptionTodaySummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionTodaySummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arrivalsCount"] = this.arrivalsCount;
        data["departuresCount"] = this.departuresCount;
        data["inHouseCount"] = this.inHouseCount;
        return data;
    }
}

export interface IReceptionTodaySummaryDto {
    arrivalsCount?: number;
    departuresCount?: number;
    inHouseCount?: number;
}

export class ReceptionReservationItemDto implements IReceptionReservationItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    status?: string;
    roomNumbers?: string[];
    roomTypeNames?: string[];
    balanceDue?: number;
    currency?: string;
    paymentMethod?: string;

    constructor(data?: IReceptionReservationItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.bookingNumber = _data["bookingNumber"];
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.status = _data["status"];
            if (Array.isArray(_data["roomNumbers"])) {
                this.roomNumbers = [] as any;
                for (let item of _data["roomNumbers"])
                    this.roomNumbers!.push(item);
            }
            if (Array.isArray(_data["roomTypeNames"])) {
                this.roomTypeNames = [] as any;
                for (let item of _data["roomTypeNames"])
                    this.roomTypeNames!.push(item);
            }
            this.balanceDue = _data["balanceDue"];
            this.currency = _data["currency"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): ReceptionReservationItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionReservationItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["bookingNumber"] = this.bookingNumber;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["status"] = this.status;
        if (Array.isArray(this.roomNumbers)) {
            data["roomNumbers"] = [];
            for (let item of this.roomNumbers)
                data["roomNumbers"].push(item);
        }
        if (Array.isArray(this.roomTypeNames)) {
            data["roomTypeNames"] = [];
            for (let item of this.roomTypeNames)
                data["roomTypeNames"].push(item);
        }
        data["balanceDue"] = this.balanceDue;
        data["currency"] = this.currency;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface IReceptionReservationItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    status?: string;
    roomNumbers?: string[];
    roomTypeNames?: string[];
    balanceDue?: number;
    currency?: string;
    paymentMethod?: string;
}

export class PendingRequestsDto implements IPendingRequestsDto {
    from?: Date;
    to?: Date;
    totals?: PendingTotalsDto;
    items?: PendingRequestItemDto[];

    constructor(data?: IPendingRequestsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"] ? new Date(_data["from"].toString()) : undefined as any;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : undefined as any;
            this.totals = _data["totals"] ? PendingTotalsDto.fromJS(_data["totals"]) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PendingRequestItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PendingRequestsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingRequestsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from ? formatDate(this.from) : undefined as any;
        data["to"] = this.to ? formatDate(this.to) : undefined as any;
        data["totals"] = this.totals ? this.totals.toJSON() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IPendingRequestsDto {
    from?: Date;
    to?: Date;
    totals?: PendingTotalsDto;
    items?: PendingRequestItemDto[];
}

export class PendingTotalsDto implements IPendingTotalsDto {
    count?: number;
    totalPendingRoomNights?: number;
    safeCount?: number;
    tightCount?: number;
    overbookCount?: number;

    constructor(data?: IPendingTotalsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.totalPendingRoomNights = _data["totalPendingRoomNights"];
            this.safeCount = _data["safeCount"];
            this.tightCount = _data["tightCount"];
            this.overbookCount = _data["overbookCount"];
        }
    }

    static fromJS(data: any): PendingTotalsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingTotalsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["totalPendingRoomNights"] = this.totalPendingRoomNights;
        data["safeCount"] = this.safeCount;
        data["tightCount"] = this.tightCount;
        data["overbookCount"] = this.overbookCount;
        return data;
    }
}

export interface IPendingTotalsDto {
    count?: number;
    totalPendingRoomNights?: number;
    safeCount?: number;
    tightCount?: number;
    overbookCount?: number;
}

export class PendingRequestItemDto implements IPendingRequestItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string | undefined;
    checkOut?: string | undefined;
    nights?: number | undefined;
    requestedRooms?: number | undefined;
    createdAtUtc?: Date;
    parsingStatus?: string;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    totalAmount?: number | undefined;
    currency?: string | undefined;
    currencyCode?: CurrencyCode | undefined;
    hotelName?: string | undefined;
    availabilityHint?: AvailabilityHintDto | undefined;

    constructor(data?: IPendingRequestItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.bookingNumber = _data["bookingNumber"];
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.nights = _data["nights"];
            this.requestedRooms = _data["requestedRooms"];
            this.createdAtUtc = _data["createdAtUtc"] ? new Date(_data["createdAtUtc"].toString()) : undefined as any;
            this.parsingStatus = _data["parsingStatus"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.totalAmount = _data["totalAmount"];
            this.currency = _data["currency"];
            this.currencyCode = _data["currencyCode"];
            this.hotelName = _data["hotelName"];
            this.availabilityHint = _data["availabilityHint"] ? AvailabilityHintDto.fromJS(_data["availabilityHint"]) : undefined as any;
        }
    }

    static fromJS(data: any): PendingRequestItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingRequestItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["bookingNumber"] = this.bookingNumber;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["nights"] = this.nights;
        data["requestedRooms"] = this.requestedRooms;
        data["createdAtUtc"] = this.createdAtUtc ? this.createdAtUtc.toISOString() : undefined as any;
        data["parsingStatus"] = this.parsingStatus;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["totalAmount"] = this.totalAmount;
        data["currency"] = this.currency;
        data["currencyCode"] = this.currencyCode;
        data["hotelName"] = this.hotelName;
        data["availabilityHint"] = this.availabilityHint ? this.availabilityHint.toJSON() : undefined as any;
        return data;
    }
}

export interface IPendingRequestItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string | undefined;
    checkOut?: string | undefined;
    nights?: number | undefined;
    requestedRooms?: number | undefined;
    createdAtUtc?: Date;
    parsingStatus?: string;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
    totalAmount?: number | undefined;
    currency?: string | undefined;
    currencyCode?: CurrencyCode | undefined;
    hotelName?: string | undefined;
    availabilityHint?: AvailabilityHintDto | undefined;
}

export class AvailabilityHintDto implements IAvailabilityHintDto {
    bucket?: string;
    availableRoomNights?: number;
    forecastSoldRoomNights?: number;
    supplyRoomNights?: number;
    pendingRoomNights?: number;
    note?: string | undefined;

    constructor(data?: IAvailabilityHintDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bucket = _data["bucket"];
            this.availableRoomNights = _data["availableRoomNights"];
            this.forecastSoldRoomNights = _data["forecastSoldRoomNights"];
            this.supplyRoomNights = _data["supplyRoomNights"];
            this.pendingRoomNights = _data["pendingRoomNights"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): AvailabilityHintDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailabilityHintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bucket"] = this.bucket;
        data["availableRoomNights"] = this.availableRoomNights;
        data["forecastSoldRoomNights"] = this.forecastSoldRoomNights;
        data["supplyRoomNights"] = this.supplyRoomNights;
        data["pendingRoomNights"] = this.pendingRoomNights;
        data["note"] = this.note;
        return data;
    }
}

export interface IAvailabilityHintDto {
    bucket?: string;
    availableRoomNights?: number;
    forecastSoldRoomNights?: number;
    supplyRoomNights?: number;
    pendingRoomNights?: number;
    note?: string | undefined;
}

export class ReceptionRoomsStatusDto implements IReceptionRoomsStatusDto {
    date?: string;
    items?: ReceptionRoomStatusItemDto[];

    constructor(data?: IReceptionRoomsStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReceptionRoomStatusItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReceptionRoomsStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionRoomsStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReceptionRoomsStatusDto {
    date?: string;
    items?: ReceptionRoomStatusItemDto[];
}

export class ReceptionRoomStatusItemDto implements IReceptionRoomStatusItemDto {
    roomId?: number;
    roomNumber?: string;
    roomTypeName?: string;
    status?: string;
    reservation?: ReceptionRoomStatusReservationDto | undefined;

    constructor(data?: IReceptionRoomStatusItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeName = _data["roomTypeName"];
            this.status = _data["status"];
            this.reservation = _data["reservation"] ? ReceptionRoomStatusReservationDto.fromJS(_data["reservation"]) : undefined as any;
        }
    }

    static fromJS(data: any): ReceptionRoomStatusItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionRoomStatusItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeName"] = this.roomTypeName;
        data["status"] = this.status;
        data["reservation"] = this.reservation ? this.reservation.toJSON() : undefined as any;
        return data;
    }
}

export interface IReceptionRoomStatusItemDto {
    roomId?: number;
    roomNumber?: string;
    roomTypeName?: string;
    status?: string;
    reservation?: ReceptionRoomStatusReservationDto | undefined;
}

export class ReceptionRoomStatusReservationDto implements IReceptionRoomStatusReservationDto {
    reservationId?: number;
    guestName?: string;
    bookingNumber?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    hotelName?: string | undefined;

    constructor(data?: IReceptionRoomStatusReservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.guestName = _data["guestName"];
            this.bookingNumber = _data["bookingNumber"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.hotelName = _data["hotelName"];
        }
    }

    static fromJS(data: any): ReceptionRoomStatusReservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionRoomStatusReservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["guestName"] = this.guestName;
        data["bookingNumber"] = this.bookingNumber;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["hotelName"] = this.hotelName;
        return data;
    }
}

export interface IReceptionRoomStatusReservationDto {
    reservationId?: number;
    guestName?: string;
    bookingNumber?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    hotelName?: string | undefined;
}

export class ReservationStatusChangedDto implements IReservationStatusChangedDto {
    reservationId?: number;
    oldStatus?: string;
    newStatus?: string;
    changedAtUtc?: Date;
    businessDate?: string;
    message?: string | undefined;

    constructor(data?: IReservationStatusChangedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedAtUtc = _data["changedAtUtc"] ? new Date(_data["changedAtUtc"].toString()) : undefined as any;
            this.businessDate = _data["businessDate"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ReservationStatusChangedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationStatusChangedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedAtUtc"] = this.changedAtUtc ? this.changedAtUtc.toISOString() : undefined as any;
        data["businessDate"] = this.businessDate;
        data["message"] = this.message;
        return data;
    }
}

export interface IReservationStatusChangedDto {
    reservationId?: number;
    oldStatus?: string;
    newStatus?: string;
    changedAtUtc?: Date;
    businessDate?: string;
    message?: string | undefined;
}

export class CheckInRequest implements ICheckInRequest {
    businessDate?: Date;
    guestName?: string | undefined;
    phone?: string | undefined;
    bookingNumber?: string | undefined;
    checkInDate?: Date | undefined;
    checkOutDate?: Date | undefined;
    balanceDue?: number | undefined;
    paymentMethod?: PaymentMethod | undefined;

    constructor(data?: ICheckInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.bookingNumber = _data["bookingNumber"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.balanceDue = _data["balanceDue"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): CheckInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["bookingNumber"] = this.bookingNumber;
        data["checkInDate"] = this.checkInDate ? this.checkInDate.toISOString() : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? this.checkOutDate.toISOString() : undefined as any;
        data["balanceDue"] = this.balanceDue;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface ICheckInRequest {
    businessDate?: Date;
    guestName?: string | undefined;
    phone?: string | undefined;
    bookingNumber?: string | undefined;
    checkInDate?: Date | undefined;
    checkOutDate?: Date | undefined;
    balanceDue?: number | undefined;
    paymentMethod?: PaymentMethod | undefined;
}

export class CheckOutRequest implements ICheckOutRequest {
    businessDate?: Date;
    balanceDue?: number | undefined;
    paymentMethod?: PaymentMethod | undefined;

    constructor(data?: ICheckOutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
            this.balanceDue = _data["balanceDue"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): CheckOutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckOutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        data["balanceDue"] = this.balanceDue;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface ICheckOutRequest {
    businessDate?: Date;
    balanceDue?: number | undefined;
    paymentMethod?: PaymentMethod | undefined;
}

export class CancelRequest implements ICancelRequest {
    reason?: string | undefined;

    constructor(data?: ICancelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): CancelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface ICancelRequest {
    reason?: string | undefined;
}

export class NoShowRequest implements INoShowRequest {
    reason?: string | undefined;
    businessDate?: Date;

    constructor(data?: INoShowRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.businessDate = _data["businessDate"] ? new Date(_data["businessDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): NoShowRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NoShowRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["businessDate"] = this.businessDate ? formatDate(this.businessDate) : undefined as any;
        return data;
    }
}

export interface INoShowRequest {
    reason?: string | undefined;
    businessDate?: Date;
}

export class ReservationAllocationPlanDto implements IReservationAllocationPlanDto {
    items?: ReservationAllocationItemDto[];

    constructor(data?: IReservationAllocationPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReservationAllocationItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReservationAllocationPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationAllocationPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReservationAllocationPlanDto {
    items?: ReservationAllocationItemDto[];
}

export class ReservationAllocationItemDto implements IReservationAllocationItemDto {
    reservationId?: number;
    guestName?: string;
    bookingNumber?: string;
    checkInDate?: Date;
    checkOutDate?: Date;
    targetNightlyPrice?: number | undefined;
    requestedRoomCount?: number;
    proposedRooms?: ProposedRoomDto[];
    candidateRooms?: ProposedRoomDto[];
    status?: string;
    warnings?: string[];

    constructor(data?: IReservationAllocationItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.guestName = _data["guestName"];
            this.bookingNumber = _data["bookingNumber"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.targetNightlyPrice = _data["targetNightlyPrice"];
            this.requestedRoomCount = _data["requestedRoomCount"];
            if (Array.isArray(_data["proposedRooms"])) {
                this.proposedRooms = [] as any;
                for (let item of _data["proposedRooms"])
                    this.proposedRooms!.push(ProposedRoomDto.fromJS(item));
            }
            if (Array.isArray(_data["candidateRooms"])) {
                this.candidateRooms = [] as any;
                for (let item of _data["candidateRooms"])
                    this.candidateRooms!.push(ProposedRoomDto.fromJS(item));
            }
            this.status = _data["status"];
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
        }
    }

    static fromJS(data: any): ReservationAllocationItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationAllocationItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["guestName"] = this.guestName;
        data["bookingNumber"] = this.bookingNumber;
        data["checkInDate"] = this.checkInDate ? this.checkInDate.toISOString() : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? this.checkOutDate.toISOString() : undefined as any;
        data["targetNightlyPrice"] = this.targetNightlyPrice;
        data["requestedRoomCount"] = this.requestedRoomCount;
        if (Array.isArray(this.proposedRooms)) {
            data["proposedRooms"] = [];
            for (let item of this.proposedRooms)
                data["proposedRooms"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.candidateRooms)) {
            data["candidateRooms"] = [];
            for (let item of this.candidateRooms)
                data["candidateRooms"].push(item ? item.toJSON() : undefined as any);
        }
        data["status"] = this.status;
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        return data;
    }
}

export interface IReservationAllocationItemDto {
    reservationId?: number;
    guestName?: string;
    bookingNumber?: string;
    checkInDate?: Date;
    checkOutDate?: Date;
    targetNightlyPrice?: number | undefined;
    requestedRoomCount?: number;
    proposedRooms?: ProposedRoomDto[];
    candidateRooms?: ProposedRoomDto[];
    status?: string;
    warnings?: string[];
}

export class ProposedRoomDto implements IProposedRoomDto {
    roomId?: number;
    roomNumber?: string;
    roomTypeName?: string;
    roomPrice?: number;
    priceDifference?: number;
    isRecommended?: boolean;

    constructor(data?: IProposedRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeName = _data["roomTypeName"];
            this.roomPrice = _data["roomPrice"];
            this.priceDifference = _data["priceDifference"];
            this.isRecommended = _data["isRecommended"];
        }
    }

    static fromJS(data: any): ProposedRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProposedRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeName"] = this.roomTypeName;
        data["roomPrice"] = this.roomPrice;
        data["priceDifference"] = this.priceDifference;
        data["isRecommended"] = this.isRecommended;
        return data;
    }
}

export interface IProposedRoomDto {
    roomId?: number;
    roomNumber?: string;
    roomTypeName?: string;
    roomPrice?: number;
    priceDifference?: number;
    isRecommended?: boolean;
}

export class GetConfirmationPlanRequest implements IGetConfirmationPlanRequest {
    reservationIds?: number[] | undefined;

    constructor(data?: IGetConfirmationPlanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reservationIds"])) {
                this.reservationIds = [] as any;
                for (let item of _data["reservationIds"])
                    this.reservationIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetConfirmationPlanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetConfirmationPlanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reservationIds)) {
            data["reservationIds"] = [];
            for (let item of this.reservationIds)
                data["reservationIds"].push(item);
        }
        return data;
    }
}

export interface IGetConfirmationPlanRequest {
    reservationIds?: number[] | undefined;
}

export class ConfirmAllocationResultDto implements IConfirmAllocationResultDto {
    confirmedCount?: number;
    failedCount?: number;
    failures?: ConfirmAllocationFailureDto[];

    constructor(data?: IConfirmAllocationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.confirmedCount = _data["confirmedCount"];
            this.failedCount = _data["failedCount"];
            if (Array.isArray(_data["failures"])) {
                this.failures = [] as any;
                for (let item of _data["failures"])
                    this.failures!.push(ConfirmAllocationFailureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfirmAllocationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAllocationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["confirmedCount"] = this.confirmedCount;
        data["failedCount"] = this.failedCount;
        if (Array.isArray(this.failures)) {
            data["failures"] = [];
            for (let item of this.failures)
                data["failures"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IConfirmAllocationResultDto {
    confirmedCount?: number;
    failedCount?: number;
    failures?: ConfirmAllocationFailureDto[];
}

export class ConfirmAllocationFailureDto implements IConfirmAllocationFailureDto {
    reservationId?: number;
    reason?: string;

    constructor(data?: IConfirmAllocationFailureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ConfirmAllocationFailureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAllocationFailureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IConfirmAllocationFailureDto {
    reservationId?: number;
    reason?: string;
}

export class ConfirmAllocationRequest implements IConfirmAllocationRequest {
    approvals?: ConfirmAllocationItem[];

    constructor(data?: IConfirmAllocationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["approvals"])) {
                this.approvals = [] as any;
                for (let item of _data["approvals"])
                    this.approvals!.push(ConfirmAllocationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfirmAllocationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAllocationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.approvals)) {
            data["approvals"] = [];
            for (let item of this.approvals)
                data["approvals"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IConfirmAllocationRequest {
    approvals?: ConfirmAllocationItem[];
}

export class ConfirmAllocationItem implements IConfirmAllocationItem {
    reservationId?: number;
    selectedRoomIds?: number[];

    constructor(data?: IConfirmAllocationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            if (Array.isArray(_data["selectedRoomIds"])) {
                this.selectedRoomIds = [] as any;
                for (let item of _data["selectedRoomIds"])
                    this.selectedRoomIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ConfirmAllocationItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmAllocationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        if (Array.isArray(this.selectedRoomIds)) {
            data["selectedRoomIds"] = [];
            for (let item of this.selectedRoomIds)
                data["selectedRoomIds"].push(item);
        }
        return data;
    }
}

export interface IConfirmAllocationItem {
    reservationId?: number;
    selectedRoomIds?: number[];
}

export class ReceptionSearchResultDto implements IReceptionSearchResultDto {
    query?: string;
    date?: string | undefined;
    results?: ReceptionReservationSearchItemDto[];

    constructor(data?: IReceptionSearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.query = _data["query"];
            this.date = _data["date"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ReceptionReservationSearchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReceptionSearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionSearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        data["date"] = this.date;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReceptionSearchResultDto {
    query?: string;
    date?: string | undefined;
    results?: ReceptionReservationSearchItemDto[];
}

export class ReceptionReservationSearchItemDto implements IReceptionReservationSearchItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    status?: string;
    roomTypeNames?: string[];
    totalNights?: number;

    constructor(data?: IReceptionReservationSearchItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"];
            this.bookingNumber = _data["bookingNumber"];
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkIn = _data["checkIn"];
            this.checkOut = _data["checkOut"];
            this.status = _data["status"];
            if (Array.isArray(_data["roomTypeNames"])) {
                this.roomTypeNames = [] as any;
                for (let item of _data["roomTypeNames"])
                    this.roomTypeNames!.push(item);
            }
            this.totalNights = _data["totalNights"];
        }
    }

    static fromJS(data: any): ReceptionReservationSearchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionReservationSearchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId;
        data["bookingNumber"] = this.bookingNumber;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["status"] = this.status;
        if (Array.isArray(this.roomTypeNames)) {
            data["roomTypeNames"] = [];
            for (let item of this.roomTypeNames)
                data["roomTypeNames"].push(item);
        }
        data["totalNights"] = this.totalNights;
        return data;
    }
}

export interface IReceptionReservationSearchItemDto {
    reservationId?: number;
    bookingNumber?: string;
    guestName?: string;
    phone?: string | undefined;
    checkIn?: string;
    checkOut?: string;
    status?: string;
    roomTypeNames?: string[];
    totalNights?: number;
}

export class ReservationDto implements IReservationDto {
    id?: number;
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    status?: ReservationStatus;
    totalAmount?: number;
    currency?: string;
    paidAtArrival?: boolean;
    source?: number;
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: number;
    currencyCode?: number;
    currencyOther?: string | undefined;
    lines?: ReservationLineDto[];

    constructor(data?: IReservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.totalAmount = _data["totalAmount"];
            this.currency = _data["currency"];
            this.paidAtArrival = _data["paidAtArrival"];
            this.source = _data["source"];
            this.hotelName = _data["hotelName"];
            this.balanceDue = _data["balanceDue"];
            this.paymentMethod = _data["paymentMethod"];
            this.currencyCode = _data["currencyCode"];
            this.currencyOther = _data["currencyOther"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(ReservationLineDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkInDate"] = this.checkInDate ? formatDate(this.checkInDate) : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? formatDate(this.checkOutDate) : undefined as any;
        data["status"] = this.status;
        data["totalAmount"] = this.totalAmount;
        data["currency"] = this.currency;
        data["paidAtArrival"] = this.paidAtArrival;
        data["source"] = this.source;
        data["hotelName"] = this.hotelName;
        data["balanceDue"] = this.balanceDue;
        data["paymentMethod"] = this.paymentMethod;
        data["currencyCode"] = this.currencyCode;
        data["currencyOther"] = this.currencyOther;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReservationDto {
    id?: number;
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    status?: ReservationStatus;
    totalAmount?: number;
    currency?: string;
    paidAtArrival?: boolean;
    source?: number;
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: number;
    currencyCode?: number;
    currencyOther?: string | undefined;
    lines?: ReservationLineDto[];
}

export class ReservationLineDto implements IReservationLineDto {
    id?: number;
    roomId?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    ratePerNight?: number;
    nights?: number;
    lineTotal?: number;

    constructor(data?: IReservationLineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roomId = _data["roomId"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeId = _data["roomTypeId"];
            this.roomTypeName = _data["roomTypeName"];
            this.ratePerNight = _data["ratePerNight"];
            this.nights = _data["nights"];
            this.lineTotal = _data["lineTotal"];
        }
    }

    static fromJS(data: any): ReservationLineDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationLineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roomId"] = this.roomId;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeId"] = this.roomTypeId;
        data["roomTypeName"] = this.roomTypeName;
        data["ratePerNight"] = this.ratePerNight;
        data["nights"] = this.nights;
        data["lineTotal"] = this.lineTotal;
        return data;
    }
}

export interface IReservationLineDto {
    id?: number;
    roomId?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    ratePerNight?: number;
    nights?: number;
    lineTotal?: number;
}

export class CreateReservationCommand implements ICreateReservationCommand {
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    paidAtArrival?: boolean;
    currency?: string;
    status?: ReservationStatus;
    lines?: CreateReservationLineCommand[];
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: PaymentMethod;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;

    constructor(data?: ICreateReservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.paidAtArrival = _data["paidAtArrival"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(CreateReservationLineCommand.fromJS(item));
            }
            this.hotelName = _data["hotelName"];
            this.balanceDue = _data["balanceDue"];
            this.paymentMethod = _data["paymentMethod"];
            this.currencyCode = _data["currencyCode"];
            this.currencyOther = _data["currencyOther"];
        }
    }

    static fromJS(data: any): CreateReservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkInDate"] = this.checkInDate ? this.checkInDate.toISOString() : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? this.checkOutDate.toISOString() : undefined as any;
        data["paidAtArrival"] = this.paidAtArrival;
        data["currency"] = this.currency;
        data["status"] = this.status;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item ? item.toJSON() : undefined as any);
        }
        data["hotelName"] = this.hotelName;
        data["balanceDue"] = this.balanceDue;
        data["paymentMethod"] = this.paymentMethod;
        data["currencyCode"] = this.currencyCode;
        data["currencyOther"] = this.currencyOther;
        return data;
    }
}

export interface ICreateReservationCommand {
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    paidAtArrival?: boolean;
    currency?: string;
    status?: ReservationStatus;
    lines?: CreateReservationLineCommand[];
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: PaymentMethod;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
}

export class CreateReservationLineCommand implements ICreateReservationLineCommand {
    roomId?: number;
    ratePerNight?: number | undefined;

    constructor(data?: ICreateReservationLineCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"];
            this.ratePerNight = _data["ratePerNight"];
        }
    }

    static fromJS(data: any): CreateReservationLineCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReservationLineCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId;
        data["ratePerNight"] = this.ratePerNight;
        return data;
    }
}

export interface ICreateReservationLineCommand {
    roomId?: number;
    ratePerNight?: number | undefined;
}

export class UpdateReservationCommand implements IUpdateReservationCommand {
    id?: number;
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    status?: ReservationStatus;
    paidAtArrival?: boolean;
    currency?: string;
    lines?: CreateReservationLineCommand[];
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: PaymentMethod;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;

    constructor(data?: IUpdateReservationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guestName = _data["guestName"];
            this.phone = _data["phone"];
            this.checkInDate = _data["checkInDate"] ? new Date(_data["checkInDate"].toString()) : undefined as any;
            this.checkOutDate = _data["checkOutDate"] ? new Date(_data["checkOutDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.paidAtArrival = _data["paidAtArrival"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(CreateReservationLineCommand.fromJS(item));
            }
            this.hotelName = _data["hotelName"];
            this.balanceDue = _data["balanceDue"];
            this.paymentMethod = _data["paymentMethod"];
            this.currencyCode = _data["currencyCode"];
            this.currencyOther = _data["currencyOther"];
        }
    }

    static fromJS(data: any): UpdateReservationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReservationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guestName"] = this.guestName;
        data["phone"] = this.phone;
        data["checkInDate"] = this.checkInDate ? this.checkInDate.toISOString() : undefined as any;
        data["checkOutDate"] = this.checkOutDate ? this.checkOutDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["paidAtArrival"] = this.paidAtArrival;
        data["currency"] = this.currency;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item ? item.toJSON() : undefined as any);
        }
        data["hotelName"] = this.hotelName;
        data["balanceDue"] = this.balanceDue;
        data["paymentMethod"] = this.paymentMethod;
        data["currencyCode"] = this.currencyCode;
        data["currencyOther"] = this.currencyOther;
        return data;
    }
}

export interface IUpdateReservationCommand {
    id?: number;
    guestName?: string;
    phone?: string | undefined;
    checkInDate?: Date;
    checkOutDate?: Date;
    status?: ReservationStatus;
    paidAtArrival?: boolean;
    currency?: string;
    lines?: CreateReservationLineCommand[];
    hotelName?: string | undefined;
    balanceDue?: number;
    paymentMethod?: PaymentMethod;
    currencyCode?: CurrencyCode;
    currencyOther?: string | undefined;
}

export class CancelReservationRequest implements ICancelReservationRequest {
    reason?: string | undefined;

    constructor(data?: ICancelReservationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): CancelReservationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CancelReservationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        return data;
    }
}

export interface ICancelReservationRequest {
    reason?: string | undefined;
}

export class RoomDto implements IRoomDto {
    id?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    floor?: number | undefined;
    status?: RoomStatus;
    isActive?: boolean;

    constructor(data?: IRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeId = _data["roomTypeId"];
            this.roomTypeName = _data["roomTypeName"];
            this.floor = _data["floor"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeId"] = this.roomTypeId;
        data["roomTypeName"] = this.roomTypeName;
        data["floor"] = this.floor;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRoomDto {
    id?: number;
    roomNumber?: string;
    roomTypeId?: number;
    roomTypeName?: string;
    floor?: number | undefined;
    status?: RoomStatus;
    isActive?: boolean;
}

export enum RoomStatus {
    Available = 1,
    OutOfService = 2,
}

export class CreateRoomCommand implements ICreateRoomCommand {
    roomNumber?: string;
    roomTypeId?: number;
    floor?: number | undefined;
    isActive?: boolean;

    constructor(data?: ICreateRoomCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomNumber = _data["roomNumber"];
            this.roomTypeId = _data["roomTypeId"];
            this.floor = _data["floor"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateRoomCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoomCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomNumber"] = this.roomNumber;
        data["roomTypeId"] = this.roomTypeId;
        data["floor"] = this.floor;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateRoomCommand {
    roomNumber?: string;
    roomTypeId?: number;
    floor?: number | undefined;
    isActive?: boolean;
}

export class UpdateRoomCommand implements IUpdateRoomCommand {
    id?: number;
    roomNumber?: string;
    roomTypeId?: number;
    floor?: number | undefined;
    status?: RoomStatus;
    isActive?: boolean;

    constructor(data?: IUpdateRoomCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roomNumber = _data["roomNumber"];
            this.roomTypeId = _data["roomTypeId"];
            this.floor = _data["floor"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateRoomCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoomCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roomNumber"] = this.roomNumber;
        data["roomTypeId"] = this.roomTypeId;
        data["floor"] = this.floor;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateRoomCommand {
    id?: number;
    roomNumber?: string;
    roomTypeId?: number;
    floor?: number | undefined;
    status?: RoomStatus;
    isActive?: boolean;
}

export class RoomTypeDto implements IRoomTypeDto {
    id?: number;
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;

    constructor(data?: IRoomTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.capacity = _data["capacity"];
            this.defaultRate = _data["defaultRate"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RoomTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        data["defaultRate"] = this.defaultRate;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRoomTypeDto {
    id?: number;
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;
}

export class CreateRoomTypeCommand implements ICreateRoomTypeCommand {
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;

    constructor(data?: ICreateRoomTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.capacity = _data["capacity"];
            this.defaultRate = _data["defaultRate"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateRoomTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoomTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        data["defaultRate"] = this.defaultRate;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateRoomTypeCommand {
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;
}

export class UpdateRoomTypeCommand implements IUpdateRoomTypeCommand {
    id?: number;
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;

    constructor(data?: IUpdateRoomTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.capacity = _data["capacity"];
            this.defaultRate = _data["defaultRate"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateRoomTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoomTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["capacity"] = this.capacity;
        data["defaultRate"] = this.defaultRate;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateRoomTypeCommand {
    id?: number;
    name?: string;
    capacity?: number;
    defaultRate?: number;
    isActive?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (this.errors as any)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (data["errors"] as any)[key] = (this.errors as any)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken?: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken?: string;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email?: string;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email?: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class InfoResponse implements IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: string;
    email?: string;
    branchId?: string | undefined;
    roles?: string[];

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.branchId = _data["branchId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["branchId"] = this.branchId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    id?: string;
    email?: string;
    branchId?: string | undefined;
    roles?: string[];
}

export class CreateUserCommand implements ICreateUserCommand {
    email?: string;
    password?: string;
    branchId?: string | undefined;
    role?: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.branchId = _data["branchId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["branchId"] = this.branchId;
        data["role"] = this.role;
        return data;
    }
}

export interface ICreateUserCommand {
    email?: string;
    password?: string;
    branchId?: string | undefined;
    role?: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    userId?: string;
    branchId?: string | undefined;
    roles?: string[];

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.branchId = _data["branchId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["branchId"] = this.branchId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserCommand {
    userId?: string;
    branchId?: string | undefined;
    roles?: string[];
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : undefined as any;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}